# MySQL面试题汇总

## 主键

### 主键的选择

- 整数自增主键
  - 好处：高效、简单
  - 示例：SERIAL类型 或 AUTO_INCREMENT属性创建自增主键。

- 复合主键
  - 由多个列组成，用来唯一地表示一个记录，通常用于多对多关系表。

- UUID
  - 以下有介绍（更适用于全局唯一标识符的场景中）

- 有意义的自然主键
  - 使用业务数据、或者有意义的数据，比如邮箱。

- 分布式主键生成策略
  - Snowflake，生成全局唯一ID并保持一定顺序（Twitter使用）

- 字符串主键
  - 不常见，但也可以。

### 分布式架构中，为什么不能使用自增主键？

1. 数据一致性问题
    - 多个数据库实例或节点同时进行数据写入（主键自增），有可能发生主键冲突，因为多节点会 independently generate 生成相同的自增主键。

2. 数据库扩展问题
    - 当想增大数据库规模到需要水平切片时，自增主键会难以管理（唯一性和顺序性变得困难）。

3. 写入热点问题
    - 写入操作会集中在特定的数据库节点上，导致其负载非常高，而其他节点负载相对较低。
    - 如果基于主键范围切片，压力集中在某个分片上，采用其他业务字段hash分片，缓解压力。

4. 不易于高可用和故障转移
    - 高可用环境中，需要快速切换到备用节点。备用节点可能需要特殊的机制来保证自增主键生成的唯一性（不同于UUID和哈希键的唯一性，自增主键在分布式环境中更复杂）。

5. 事务和ACID属性
    - 分布式环境中维持原子性、一致性、隔离性、持久性是困难的，自增主键会增加这一困难，因为需要在多节点上协调主键分配，会增加系统复杂性和风险。
    - 使用 AUTO_INCREMENT 配合 replace into 自增ID，每当插入数据时，都会占用自增锁和插入锁。

### 分布式系统中，UUID可以做主键么？存在哪些问题？

UUID是由32个十六进制的数字和4个连字符组成的。

#### 优点

1. 全局唯一：它可以确保所有节点的唯一性，减少冲突的可能性。

2. 无需协调：多个节点可以independently生成UUID，无需中心化的协调，降低了系统复杂度和潜在风险。

#### 缺点

1. 存储开销：UUID通常比简单的整数主键需要更多的存储空间（UUID需要16字节，INT只需要4字节）

2. 性能问题：UUID是无序的，可能会导致数据库在执行插入操作时发生页分裂，降低数据库的性能。

3. 不易读：长串字符。

4. 索引效率降低：其随机性可能会降低索引效率，导致更频繁的 I/O操作和较低的缓存命中率。

#### 扩展

1. 页分裂 Page Split：
    - 原理：
      - 插入新纪录：当一个新的记录被插入到一个已满的数据页中时，发生页分裂。
      - 创建新页面：数据库系统创建一个新的数据页。
      - 重新分配记录：原来的数据页中的一些记录被移动到新的数据页中，以腾出空间来容纳新的记录。
    - 问题：
      - 性能下降：页分裂是一个资源密集型的操作，因为它涉及到数据的移动和索引的更新。
      - 碎片化：随着时间的推移，频繁的页面分裂可以导致数据碎片化，这可以降低查询性能。
    - UUID和页分裂：
      - 随即插入：UUID通常是随机生成的，这意味着新的记录可以被插入到表的任何位置，这增加了页分裂的可能性。

2. 降低索引效率
    - 原理：
      - B-tree索引：数据被存储在一个树型结构中，其中每个节点包含一个数据范围。当一个新的值被插入时，它被放在对应范围内。
    - 问题：
      - 频繁的I/O操作：由于UUID是随机的，因此索引树的各个部分会被频繁访问，导致更多的I/O操作和更低的缓存命中率。
    - UUID和索引效率：
      - 随机访问：UUID的随机性意味着索引结构可能不会得到良好的利用，因为数据访问模式也是随机的。
    - 例子：执行查询，该查询需要访问多个由UUID标识的行。由于UUID是随机生成的，这些行可能分散在整个索引结构中，导致需要更多的查询时间。

3. 更低地缓存命中率

缓存机制将最近或最频繁访问的数据页保存在内存中，减少对磁盘的I/O操作来提高性能。

- 随机插入：UUID的随机性使新记录可以插入到表的任何位置，导致数据库必须频繁地加载和卸载不同的数据页，降低了缓存的效用。

- 随机读取：通过UUID查询数据时，会访问表中分布在不同地方的行，导致数据库可能从磁盘中读取多个不同的数据页，而这些都没在缓存中。

- 降低缓存命中的影响：随机访问模式，导致数据页在缓存中留存的时间降低，因为会被近期访问的数据替换。

#### 措施

1. 使用有意义的UUID：时间戳+机器ID，提供一些排序能力和额外有意义信息。
2. 压缩UUID：删除UUID中的破折号或使用特殊方案来减少UUID的大小。
3. 使用COMB（Combined GUID / UUID）：它结合了GUID和时间戳来创建一个更顺序的标识符，可以减少页分裂和其他性能问题。

### 雪花算法（SnowFlake）可以生成得主键，请描述其原理，并介绍它的优势和不足，如何解决不足？

Twitter开发的一个用于生成64位的ID应用，产生ID是一个长整型数字。该算法确保每毫秒产生4096个唯一ID。

#### 结构

- 41位的时间序列：用来记录时间戳，单位是毫秒。

- 10位的机器ID：用来记录该ID是由哪个机器生成的。这10位又可以细分为5位数据中心ID和5位机器ID。

- 12位序列号：在毫秒内的计数。

#### 优点

1. 高效：快速地生成大量的唯一ID。

2. 时间有序：包含时间戳信息，所以生成的ID是时间有序的。

3. 分布式系统适应性强：通过数据中心ID和机器ID来避免冲突。

#### 不足

1. 时间依赖：该算法依赖于系统时间，所以如果系统时间被调整，将会影响ID的生成。

2. 单点故障：如果一个节点发生故障，那么它将不再能够生成ID。

3. 可用ID数量的限制：虽然41位的时间序列可以支持约69年的时间，但是如果系统的生命周期超过这个时间，将需要找到新的解决方案。

#### 解决不足

1. 时钟回拨问题：
   - 通过在系统检测到时钟回拨时拒绝分配ID来解决时钟回拨问题。
   - 使用NTP来同步系统时间。
   - 现根据当前时间生成时间戳，再减去系统上线的时间。

2. 单点故障：可以通过引入多个独立的SnowFlake节点来解决单点故障问题，以实现高可用性。

3. 可用ID数量的限制：可以通过重新定义位的分配来扩展系统的生命周期，比如减少机器ID的位数来增加时间序列的位数。